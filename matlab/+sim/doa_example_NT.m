function result = doa_example_NT(q,param)
% script sim.doa_example_NT
% This script generates suboptimal likelihood values for NT model order
% estimation method.
%
% Author: John Paden, Theresa Stumpf , Sravya Athinarapu
%
physical_constants;
DOA_true = q;
Nc      = param.Nc;
N_snap  = param.monte.Nsnap ;
SNR_db  = param.SNR_db  ;
M       = param.M;
param.monte.random_seed_offset = 1;
param_MOE = param.param_MOE;

%% Setup simulation parameters

for SNR_idx = 1:length(SNR_db)
    if length(DOA_true) == 0;   %% SRAVYA
        param.monte.SNR   = -inf ;
        num_tests = 1;
        param.monte.DOA   = [];
    else
        param.monte.SNR   = repmat(SNR_db(SNR_idx),1, length(DOA_true));  %% SNR 10dB used in the CHEN paper
        num_tests = 1;
        param.monte.DOA   = repmat(DOA_true,[num_tests 1]);
    end
    for N_idx = 1: length(N_snap)
        % N :number of snapshots
        N = N_snap (N_idx);
        
        % M : Maximum number of signals
        
        %1:M  %% possible range of k (number of signals)
        for Nsig_tmp = 1      % FOR COMPARISION WE DO NOT NEED DOA SO ONE SIMULATION RESULTS ENOUGH FROM doa WHICH IS DCM
            
            % CHANGE THIS TO 1:M WHEN WE WANTED TO RUN OPTIMAL METHODS
            % SINCE WE WANT DOA
            
            param.Nsig_tmp = Nsig_tmp;
            
            
            %% Run the simulation
            % This section used in doa_example1
            
            %   if Nsig_tmp == 1
            %   [results{Nsig_tmp}, DCM_runs] = sim.doa(param,[]);
            %   elseif Nsig_tmp > 1
            %   doa_prev = squeeze(results{1,Nsig_tmp-1}.theta_est{1,param.method.list});
            %   [results{Nsig_tmp}, DCM_runs] = sim.doa(param, doa_prev(:,1:Nsig_tmp-1));
            %   end
            %
            
            % Simulate array data for Training NT
            [results_NT, DCM_runs_NT] = sim.doa(param);
            
            %%%%%%% RMSE{Nsig_tmp} = sim.doa_rmse(param,results{Nsig_tmp});
            
            %%%%%    doa_tmp(1:param.monte.runs,:) = squeeze(results{1, Nsig_tmp}.theta_est{1, param.method.list});
            
            %%%%%    doa_mle_all{Nsig_tmp} = doa_tmp(:,1:Nsig_tmp) *180/pi; % each cell contain DOA for all runs. row indicates the run number.
            
            
        end
        
        for run_idx = 1:param.monte.runs
            % % % % % %     %arranging all doa for possible k for a single run.
            % % % % % %     for Nsig_tmp = 1:M  %%%%%CHANGE
            % % % % % %
            % % % % % %       doa_mle{Nsig_tmp} = doa_mle_all{Nsig_tmp}(binIdx,:) ;
            % % % % % %
            % % % % % %     end
            % % % % % %
            
            Rxx = DCM_runs_NT{run_idx};
            
            % l: eigen values
            [eigval,index] = sort(eig(Rxx),'descend');
            
            % DCM is symmetric and always we get real eigen values. due to some
            % rounding errors in the data generated by matlab we got complex eigen
            % values
            
            eigval = real(eigval);
%             [V,D] = eig(Rxx);
            %u: eigen vectors
%             u = V(:,index);
            
            for k = 0:M
                log_lq_term1 =sum(log(eigval(k+1:end))); %natural log
                log_lq_term2 =(Nc-k)* (  log(   sum(   (eigval(k+1:end))  /  (Nc-k)  )   )    );
                
                log_lq(k+1) = N*(log_lq_term1  -   log_lq_term2);
                DOF(k+1) = k*((2*Nc)-k) + 1;  % degree of freedom of the space spanned by signal vectors
                
                log_func(k+1) = - 2 * log_lq(k+1);
                penality(k+1) =  0;   %CHANGE LATE
            end
            
            if param_MOE.norm_allign_zero ==1
                log_func = log_func + param_MOE.norm_term_suboptimal;
            end
            
            cost = log_func + penality;
            
            [~, index] = min(cost);
            sources_number(SNR_idx,N_idx,run_idx) = index-1;
            log_func_runs(run_idx,:) = log_func;
            penality_runs(run_idx,:) = penality;
            cost_runs(run_idx,:) = cost;
            
            diff_log_func(run_idx,:) = diff(log_func_runs(run_idx,:));
            diff_penality(run_idx,:) = diff(penality_runs(run_idx,:));
        end
        log_func_all{SNR_idx,N_idx} = log_func_runs;
        penality_all{SNR_idx,N_idx} = penality_runs;
        cost_all{SNR_idx,N_idx} = cost_runs;
        
        diff_log_func_all{SNR_idx,N_idx} = diff_log_func;
        diff_penality_all{SNR_idx,N_idx} = diff_penality;
    end
    
    % figure(length(q)+5)
    % subplot(2,2,SNR_idx)
    % plot(1:p-1 ,-1*diff_log_func_all{SNR_idx})
    % grid on
    % title('log-likelihood diff b/w sources');
    % ylabel('magniude');
    % xlabel('Index');
    % % legend('diff log func','diff penality' ,'location', 'east')
    %
    
    if isempty(DOA_true)
        penalty_min_jump_SNR(SNR_idx) = max(-1*diff_log_func_all{SNR_idx}(:,length(DOA_true)+1));
    else
        penalty_min_jump_SNR(SNR_idx) = max(-1*diff_log_func_all{SNR_idx}(:,length(DOA_true)));
    end
end
result.log_func_all =log_func_all;
result.penalty_min_jump_SNR = penalty_min_jump_SNR ;
return;

