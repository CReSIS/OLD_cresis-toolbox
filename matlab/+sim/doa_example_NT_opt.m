function result = doa_example_NT_opt(q,param)
% script sim.doa_example_NT
% This script generates suboptimal likelihood values for NT model order
% estimation method.
%
% Author: John Paden, Theresa Stumpf , Sravya Athinarapu
%
physical_constants;
DOA_true = q;
Nc       = param.Nc;
N_snap   = param.monte.Nsnap ;
SNR_db   = param.SNR_db  ;
param.monte.random_seed_offset = 1;
M = param.M;
param_MOE = param.param_MOE;

%% Setup simulation parameters

for SNR_idx = 1:length(SNR_db)
    if length(DOA_true) == 0;   %% SRAVYA
        param.monte.SNR   = -inf ;
        num_tests = 1;
        param.monte.DOA   = [];
    else
        param.monte.SNR   = repmat(SNR_db(SNR_idx),1, length(DOA_true));  %% SNR 10dB used in the CHEN paper
        num_tests = 1;
        param.monte.DOA   = repmat(DOA_true,[num_tests 1]);
    end
    
    for N_idx = 1: length(N_snap)
        % N :number of snapshots
        Nsnap = N_snap (N_idx);
        
        % M : Maximum number of signals
        
        % possible range of k (number of signals)
        for Nsig_tmp = 1:M   % = 1      % FOR COMPARISION WE DO NOT NEED DOA SO ONE SIMULATION RESULTS ENOUGH FROM doa WHICH IS DCM
            
            % CHANGE THIS TO 1:M WHEN WE WANTED TO RUN OPTIMAL METHODS
            % SINCE WE WANT DOA
            param.Nsig_tmp = Nsig_tmp;
            %% Run the simulation
            % This section used in doa_example1
            
            %   if Nsig_tmp == 1
            %   [results{Nsig_tmp}, DCM_runs] = sim.doa(param,[]);
            %   elseif Nsig_tmp > 1
            %   doa_prev = squeeze(results{1,Nsig_tmp-1}.theta_est{1,param.method.list});
            %   [results{Nsig_tmp}, DCM_runs] = sim.doa(param, doa_prev(:,1:Nsig_tmp-1));
            %   end
            %
            % Simulate array data for Training NT
            [results_NT{Nsig_tmp}, DCM_runs_NT] = sim.doa(param);
            %%%%%%% RMSE{Nsig_tmp} = sim.doa_rmse(param,results{Nsig_tmp});
            doa_tmp(1:param.monte.runs,:) = squeeze(results_NT{1, Nsig_tmp}.theta_est{1, param.method.list});
            
            doa_mle_all{Nsig_tmp} = doa_tmp(:,1:Nsig_tmp) *180/pi; % each cell contain DOA for all runs. row indicates the run number.
        end
        bin = param.monte.runs;  % for now
        
        for binIdx = 1:bin;
            %arranging all doa for possible k for a single run.
            for Nsig_tmp = 1:M  %%%%%CHANGE
                doa_mle{Nsig_tmp} = doa_mle_all{Nsig_tmp}(binIdx,:) ;
            end
            
            Rxx = DCM_runs_NT{binIdx};
            
            % l: eigen values
            [l,index] = sort(eig(Rxx),'descend');
            
            % DCM is symmetric and always we get real eigen values. due to some
            % rounding errors in the data generated by matlab we got complex eigen
            % values
            
            l = real(l);
            l_all(bin,:) = l;
            [V,D] = eig(Rxx);
            %u: eigen vectors
            u = V(:,index);
            
            %NT for optimal
            p = size(Rxx,1);
            M = param.M; % max number of sources we are trying to estimate (it can go mupto Nc-1)
            
            for k = 0:M   %%%%CHANGE
                if k == 0
                    %Proj{k+1} = eye(Nc);
                    Proj{k+1} = 0;
                else
                    sv = exp(1i*pi*sind(doa_mle{k}.')*(0:Nc-1)).';
                    
                    Proj{k+1} = sv*(inv(  (sv')*sv ))* (sv') ;
                end
                
                for p_idx = 1:Nc
                    term1(k+1,p_idx) = l(p_idx).*norm((eye(Nc)-Proj{k+1})*u(:,p_idx))^2;
                end
                
                sum_term(k+1) = sum(term1(k+1,:));
                DOF(k+1) = k*((2*Nc)-k) + 1;  % degree of freedom of the space spanned by signal vectors
            end
            
            log_func = -2*(-Nsnap*p*(log((sum_term)/p)))  ;
            if param_MOE.norm_allign_zero ==1
                log_func = log_func  + param_MOE.norm_term_optimal;
            else
                log_func = log_func + param_MOE.opt_norm_term;
                
            end
            
            penality= zeros(size(log_func));   %CHANGE LATER
            cost = log_func + penality;
            
            [~, index] = min(cost);
            sources_number(SNR_idx,N_idx,binIdx) = index-1;
            log_func_runs(binIdx,:) = log_func;
            penality_runs(binIdx,:) = penality;
            cost_runs(binIdx,:) = cost;
            
            clear log_func penalty cost
            
            diff_log_func(binIdx,:) = diff(log_func_runs(binIdx,:));
            diff_penality(binIdx,:) = diff(penality_runs(binIdx,:));
        end
        log_func_all{SNR_idx,N_idx} = log_func_runs;
        penality_all{SNR_idx,N_idx} = penality_runs;
        cost_all{SNR_idx,N_idx} = cost_runs;
        
        diff_log_func_all{SNR_idx,N_idx} = diff_log_func;
        diff_penality_all{SNR_idx,N_idx} = diff_penality;
    end
    
    % figure(length(q)+5)
    % subplot(2,2,SNR_idx)
    % plot(1:p-1 ,-1*diff_log_func_all{SNR_idx})
    % grid on
    % title('log-likelihood diff b/w sources');
    % ylabel('magniude');
    % xlabel('Index');
    % % legend('diff log func','diff penality' ,'location', 'east')
    %
    
    if isempty(DOA_true)
        penalty_min_jump_SNR(SNR_idx) = max(-1*diff_log_func_all{SNR_idx}(:,length(DOA_true)+1));
       
    else
        penalty_min_jump_SNR(SNR_idx) = max(-1*diff_log_func_all{SNR_idx}(:,length(DOA_true)));
    end
end
result.log_func_all =log_func_all;
result.penalty_min_jump_SNR = penalty_min_jump_SNR ;
result.doa = doa_mle_all;
return;

